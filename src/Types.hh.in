/* 
   phred - Phred is a parallel finite difference time domain
   electromagnetics simulator.

   Copyright (C) 2004 Matt Hughes <mhughe@uvic.ca>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
*/

/* This file defines the types used for various things. This
 * is processed by autoconf so we can set types based on switches or
 * machine type.
 */

/* Use only C comments, or the AIX C compiler with complain */ 

#ifndef TYPES_H
#define TYPES_H

/**
 * Target platform 
 */ 
static const char *PLATFORM = "@target@";

/**
 * Indicators for CSG operations. 
 */
enum CSGStatus {
  INSIDE,
  BOUNDARY,
  OUTSIDE
};

/**
 * Multipliers used to get meters from a user's input. 
 */ 
static const float METER = 1.0;
static const float DECIMETER = 0.1;
static const float CENTIMETER = 1e-2;
static const float MILLIMETER = 1e-3;
static const float MICROMETER = 1e-6;
static const float NANOMETER = 1e-9;
static const float PICOMETER = 1e-12;
static const float FEMTOMETER = 1e-15;

/**
 * Axis of rotation
 */
enum Axis {
  X_AXIS,
  Y_AXIS, 
  Z_AXIS
};

/**
 * Things than can be stored in the grid's auxilary data map. 
 */
enum GridAuxData {
  PML_COMMON,
  UPML_COMMON
};

/**
 * Boundary conditions. These can be appled to faces of the grid or to
 * the surfaces of materials. But normally just to the faces of the
 * grid.
 */
enum BoundaryCondition {
  UNKNOWN, /**< The boundary condition is unknown; non-sane. */
  SUBDOMAIN, /**< Means that the face is shared with another node */
  EWALL, /**< Electric wall */
  HWALL, /**< Magnetic wall */
  PML, /**< Perfectly matched layers (Berenger's absorbing boundary) */
  UPML /**< Gedney's uniaxial PML */ 
  /* MUR */ /**< 2nd order absorbing boundary condition */
  /* IMPEDANCE, */ /**< Imedance boundary */
};

/** 
 * Material types. Not currently used, but may be used to indicate the
 * type of grid that should be used.
 */
enum MaterialType {
  PERF_COND, 
  NON_PERMEABLE, 
  CONDUCTIVE, 
  DEBYE, 
  LORENTZ, 
  DRUDE
};

/**
 * Faces on the grid cube.
 */
enum Face {
  FRONT = 0, /**< x = dimx, YZ plane */
  BACK = 1, /**< x = 0, YZ plane */
  LEFT = 2, /**< y = 0, XZ plane */
  RIGHT = 3, /**< y = dimy, XZ plane */
  BOTTOM = 4, /**< z = 0, XY plane */
  TOP = 5 /**< z = dimz, XY plane */
};

/**
 * Field components. Electric and magnetic
 */
enum FieldComponent {
  FC_EX,
  FC_EY,
  FC_EZ,
  FC_HX, 
  FC_HY, 
  FC_HZ, 
  FC_E, /* E field intensity */
  FC_H /* H field intensity */ 
};

/**
 * Field types, E and H
 */
enum FieldType {
  E,
  H,
  BOTH
};

/**
 * The type used for material coefficients
 */
typedef float mat_coef_t; 

/**
 * The type used for material properties
 */
typedef float mat_prop_t;

/**
 * The type used for grid field components, THE MPI DATATYPE MUST MATCH!
 */
/* typedef float field_t; */
/* #define GRID_MPI_TYPE MPI_FLOAT */
typedef @FIELD_TYPE@ field_t;
#define GRID_MPI_TYPE @MPIFIELD_TYPE@

/**
 * The type used for grid spacings
 */
typedef @FIELD_TYPE@ delta_t;

/** \struct region
 * \brief min and max coordinates that can be used to define a
 * block within the grid. Or a face. 
 */
typedef struct region_str {
  unsigned int xmin;
  unsigned int xmax;
  unsigned int ymin;
  unsigned int ymax;
  unsigned int zmin;
  unsigned int zmax;
} region_t;

#ifdef __cplusplus
/**
 * Represents a point in real space. 
 */ 
class point
{
public:
  float x;
  float y;
  float z;

  point()
    : x(0), y(0), z(0)
  {}

  point(float xn, float yn, float zn)
    : x(xn), y(yn), z(zn)
  {}
};

/**
 * Represents a single point in the Grid. The class constructor makes it
 * easy to construct temporary objects for more terse syntax
 */
class point_t
{
public:
  unsigned int x;
  unsigned int y;
  unsigned int z;

  point_t()
    : x(0), y(0), z(0)
  {}

  point_t(unsigned int xn, unsigned int yn, unsigned int zn)
    : x(xn), y(yn), z(zn)
  {}
};
#else
typedef struct {
  unsigned int x;
  unsigned int y;
  unsigned int z;
} point_t;

typedef struct {
  float x;
  float y;
  float z;
} point;

#endif

typedef point_t grid_point;

#endif

